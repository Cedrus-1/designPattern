### Factory 工厂模式

#### 1. 简单工厂模式 SimpleFactory Pattern
* 简单工厂模式（SimpleFactory Pattern）是指由一个工厂对象决定创建出哪一种产品类的实例，
但它不属于GOF 23种设计模式（参考资料：http://en.wikipedia.org/wiki/Design_Patterns#Patterns_by_Type）
* 简单工厂适用于工厂类负责创建的对象较少的场景，且客户端只需要传入工厂类的参数，对于如何创建对象的逻辑不需要关心。
##### 缺点：
* 工厂类的职责相对过重，不易于扩展过于复杂的产品结构。 

#### 2. 工厂方法模式 FactoryMethodPattern
* 工厂方法模式（FatoryMethodPattern）是指定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，
工厂方法让类的实例化推迟到子类中进行。在工厂方法模式中用户只需要关心所需产品对应的工厂，无须关心创建细节，
而且加入新的产品符合开闭原则。
* 工厂方法模式主要解决产品扩展的问题，在简单工厂中，随着产品链的丰富，如果每个课程的创建逻辑有区别的话，
工厂的职责会变得越来越多，有点像万能工厂，并不便于维护。
根据单一职责原则我们将职能继续拆分，专人干专事。
##### 工厂方法适用于以下场景
* 创建对象需要大量重复的代码。
* 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节。
* 一个类通过其子类来指定创建哪个对象。
##### 缺点
* 类的个数容易过多，增加复杂度。
* 增加了系统的抽象性和理解难度。

#### 3. 抽象工厂模式（Abastract Factory Pattern）
* 抽象工厂模式（Abastract Factory Pattern）是指提供一个创建一系列相关或相互依赖对象的接口，无须指定他们具体的类。
客户端（应用层）不依赖于产品类实例如何被创建、实现等细节，强调的是一系列相关的产品对象（属于同一产品族）
一起使用创建对象需要大量重复的代码。需要提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。
##### 缺点
* 规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。
* 增加了系统的抽象性和理解难度。

--------
uml图：resources.com.cedrus.design.factory