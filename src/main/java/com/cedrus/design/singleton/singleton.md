# 单例模式
单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并
提供一个全局访问点。单例模式是创建型模式。单例模式在现实生活中应用也非常广泛。
例如，国家主席、公司 CEO、部门经理等。在 J2EE 标准中，ServletContext、
ServletContextConfig等；在Spring框架应用中ApplicationContext；数据库的连接
池也都是单例形式。
单例模式可以保证内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用

## 1. 饿汉式单例
饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线
程还没出现以前就是实例化了，不可能存在访问安全问题。
优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。
缺点：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存。

## 2. 懒汉式单例
懒汉式单例的特点是：被外部类调用的时候内部类才会加载。
### 简单懒汉式单例
优点：避免内存浪费
缺点：存在线程安全问题
### 加锁懒汉式单例
synchronized 关键字解决了线程安全问题，但是存在一定的性能问题
### 双重锁懒汉式单例
在加锁式懒汉模式上性能有所改进， 但还是有一定性能问题
## 内部类的懒汉单例
式兼顾饿汉式的内存浪费，也兼顾synchronized性能问题

### 执行逻辑：
1.未使用LazyInnerClassSingleton之前，内部类LazyHolder也不会创建
2. 调用LazyInnerClassSingleton.getInstance() 方法的时候，
* 先初始化内部类LazyHolder：初始化LazyHolder 静态私有成员 LAZY
3. 初始化LazyInnerClassSingleton 
* 调用私有构造方法LazyInnerClassSingleton()
* 调用getInstance方法，返回单例
时序图见 resources/com/cedrus/design/singleton/singleton.png

## 3. 注册式单例
注册式单例又称为登记式单例，就是将每一个实例都登记到某一个地方，使用唯一的标
识获取实例。注册式单例有两种写法：一种为容器缓存，一种为枚举登记



# 单例破坏现象
## 1. 反射破坏单例
虽然构造方法私有化，但还是可以通过反射强制访问，创建相应的实例
解决办法：在其构造方法中做一些限制，比如：一旦出现多次重复创建，则直接抛出异常
## 2. 序列化破坏单例
将对象序列化过后，然后反序列化读取到对象，反序列化后的对象会重新分配内存，
即重新创建，导致该对象与单例中对象不一致。
解决办法：重写readResolve()方法
